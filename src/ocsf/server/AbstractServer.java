package ocsf.server;import java.io.IOException;import java.io.InterruptedIOException;import java.net.ServerSocket;import java.net.Socket;public abstract class AbstractServer  implements Runnable{  private ServerSocket serverSocket = null;    private Thread connectionListener;    private int port;    private int timeout = 500;    private int backlog = 10;    private ThreadGroup clientThreadGroup;    private boolean readyToStop = false;    public AbstractServer(int port)  {    this.port = port;        clientThreadGroup =       new ThreadGroup("ConnectionToClient threads")      {        public void uncaughtException(Thread thread, Throwable exception)        {          clientException((ConnectionToClient)thread, exception);        }      };    }        public final void listen()      throws IOException    {      if (!isListening())      {        if (serverSocket == null)        {          serverSocket = new ServerSocket(getPort(), backlog);        }                serverSocket.setSoTimeout(timeout);        readyToStop = false;        connectionListener = new Thread(this);        connectionListener.start();      }    }        public final void stopListening()    {      readyToStop = true;    }        public final synchronized void close()      throws IOException    {      if (serverSocket == null)        return;      stopListening();            try { serverSocket.close();      }      finally      {        Thread[] clientThreadList = getClientConnections();        for (int i = 0; i < clientThreadList.length; i++)        {          try          {            ((ConnectionToClient)clientThreadList[i]).close();          }          catch (Exception localException) {}        }                serverSocket = null;        serverClosed();      }    }        public void sendToAllClients(Object msg)    {      Thread[] clientThreadList = getClientConnections();            for (int i = 0; i < clientThreadList.length; i++)      {        try        {          ((ConnectionToClient)clientThreadList[i]).sendToClient(msg);        }        catch (Exception localException) {}      }    }        public final boolean isListening()    {      return connectionListener != null;    }        public final synchronized Thread[] getClientConnections()    {      Thread[] clientThreadList = new Thread[        clientThreadGroup.activeCount()];            clientThreadGroup.enumerate(clientThreadList);            return clientThreadList;    }        public final int getNumberOfClients()    {      return clientThreadGroup.activeCount();    }        public final int getPort()    {      return port;    }        public final void setPort(int port)    {      this.port = port;    }        public final void setTimeout(int timeout)    {      this.timeout = timeout;    }        public final void setBacklog(int backlog)    {      this.backlog = backlog;    }        public final void run()    {      serverStarted();            try      {        while (!readyToStop)        {          try          {            Socket clientSocket = serverSocket.accept();                        synchronized (this)            {              ConnectionToClient localConnectionToClient = new ConnectionToClient(                clientThreadGroup, clientSocket, this);            }          }          catch (InterruptedIOException localInterruptedIOException) {}        }                serverStopped();      }      catch (IOException exception)      {        if (!readyToStop)        {          listeningException(exception);        }        else        {          serverStopped();        }      }      finally      {        readyToStop = true;        connectionListener = null;      }    }        protected void clientConnected(ConnectionToClient client) {}        protected synchronized void clientDisconnected(ConnectionToClient client) {}        protected synchronized void clientException(ConnectionToClient client, Throwable exception) {}        protected void listeningException(Throwable exception) {}        protected void serverStarted() {}        protected void serverStopped() {}        protected void serverClosed() {}        protected abstract void handleMessageFromClient(Object paramObject, ConnectionToClient paramConnectionToClient);        final synchronized void receiveMessageFromClient(Object msg, ConnectionToClient client)    {      handleMessageFromClient(msg, client);    }  }